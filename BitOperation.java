//位运算
// >> 算数右移:低位溢出,符号位不变,并用符号位补溢出的高位
// << 算数左移:符号位不变,地位补0
// >>> 逻辑右移/无符号右移:低位溢出,高位补0
//正数的算数右移和逻辑右移相同

// ~ 按位取反:0变1,1变0
// & 按位与:两位全为1,结果为1,否则为0
// | 按位或:两位任一个为1,结果为1,否则为0
// ^ 按位异或:两位一个是0一个是1,结果为1,否则为0

//原码反码补码
//对于有符号的而言:
//1.二进制的最高位是符号位:0代表正数,1代表负数
//2.正数的原码反码补码都一样,三码合一
//3.负数的反码=原码符号位不变,其他位取反(0变1,1变0)
//4.负数的补码=反码+1,反码=补码-1
//5.0的反码补码都是0
//6.java没有无符号数,java中的数都是有符号的
//7.计算机运算时都是以补码的方式来运算的(补码统一了正负数)
//8.运算结果看的是原码


//导入扫描器
import java.util.Scanner;

public class BitOperation {
	public static void main(String[] args) {
		System.out.println(2 & 3);//2按位与3 = 2
		//正数的原码反码补码都一样,三码合一
		//2的原码 00000000 00000000 00000000 00000010
		//2的补码 00000000 00000000 00000000 00000010
		//3的原码 00000000 00000000 00000000 00000011
		//3的补码 00000000 00000000 00000000 00000011
		//按位与=:两位全为1,结果为1,否则为0
		//按位与 :00000000 00000000 00000000 00000010(这是补码)
		//对应原码:  00000000 00000000 00000000 00000010
		//对应数字:2

		System.out.println(~-2);//按位取反-2 = 1
		//3.负数的反码=原码符号位不变,其他位取反(0变1,1变0)
		//4.负数的补码=反码+1,反码=补码-1
		//-2的原码:10000000 00000000 00000000 00000010
		//对应反码:11111111 11111111 11111111 11111101
		//对应补码:11111111 11111111 11111111 11111110
		//按位取反:00000000 00000000 00000000 00000001(这是补码)
		//对应原码:00000000 00000000 00000000 00000001
		//对应数字:1

		System.out.println(~2);//按位取反2 = -3
		//2的原码:00000000 00000000 00000000 00000010
		//2的补码:00000000 00000000 00000000 00000010
		//按位取反:11111111 11111111 11111111 11111101(这是补码)
		//对应反码:11111111 11111111 11111111 11111100
		//对应原码:10000000 00000000 00000000 00000011
		//对应数字:-3

		System.out.println(2 | 3);//2按位或3 = 3
		//2的补码:00000000 00000000 00000000 00000010
		//3的补码:00000000 00000000 00000000 00000011
		//按位或 :00000000 00000000 00000000 00000011(这是补码)
		//对应原码:00000000 00000000 00000000 00000011
		//对应数字:3

		System.out.println(2 ^ 3);//2按位异或3 = 1
		//2的补码:00000000 00000000 00000000 00000010
		//3的补码:00000000 00000000 00000000 00000011
		//按位异或:00000000 00000000 00000000 00000001(这是补码)
		//对应原码:00000000 00000000 00000000 00000001
		//对应数字:1

		System.out.println(~-5);//按位取反-5 = 4
		//-5的原码:10000000 00000000 00000000 00000101
		//-5的反码:11111111 11111111 11111111 11111010
		//-5的补码:11111111 11111111 11111111 11111011
		//按位取反:00000000 00000000 00000000 00000100(这是补码)
		//对应原码:00000000 00000000 00000000 00000100
		//对应数字:4

		System.out.println(13 & 7);//13按位与7 = 5
		//13的补码:00000000 00000000 00000000 00001101
		//7的补码 :00000000 00000000 00000000 00000111
		//按位与  :00000000 00000000 00000000 00000101(这是补码)
		//对应原码:00000000 00000000 00000000 00000101
		//对应数字:5

		System.out.println(5 | 4);//5按位或4 = 5
		//5的补码:00000000 00000000 00000000 00000101
		//4的补码:00000000 00000000 00000000 00000100
		//按位或 :00000000 00000000 00000000 00000101(这是补码)
		//对应原码:00000000 00000000 00000000 00000101
		//对应数字:5

		System.out.println(-3 ^ 3);//-3按位异或3 = -2
		//-3的原码:10000000 00000000 00000000 00000011
		//-3的反码:11111111 11111111 11111111 11111100
		//-3的补码:11111111 11111111 11111111 11111101
		//3的补码 :00000000 00000000 00000000 00000011
		//按位异或:11111111 11111111 11111111 11111110(这是补码)
		//对应反码:11111111 11111111 11111111 11111101
		//对应原码:10000000 00000000 00000000 00000010
		//对应数字:-2



		//以下数字采用8位演示
		byte a = 1 >> 2;//本质 1/2/2 == 0
		//1的补码:00000001
		//右移2位:00000000(这是补码)
		//对应原码:00000000(数字0)
		byte b = -1 >> 2;
		//-1的原码:10000001
		//-1的反码:11111110
		//-1的补码:11111111
		//右移1位:11111111
		//右移2位:11111111(这是补码)
		//对应反码:11111110
		//对应原码:10000001(数字-1)
		byte c = 1 << 2;//本质 1*2*2 == 4
		//1的补码:00000001
		//左移2位:00000100(这是补码)
		//对应数字:4
		byte d = -1 << 2;
		//-1的原码:10000001,反码:11111110,补码:11111111
		//左移2位:11111100(这是补码),对应反码:11111011,对应原码:10000100,数字-4

		System.out.println("a = " + a);//0
		System.out.println("b = " + b);//-1
		System.out.println("c = " + c);//4
		System.out.println("d = " + d);//-4
	}
}